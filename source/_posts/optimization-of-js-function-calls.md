---
title: js函数调用的优化
---

作为程序员总是对性能很在意,生怕自己的误操作造成大量浪费,好像指挥千百万小人做着无效的工作,它们不会反抗、只会忠实地执行.就像自己浪费了一生,这种愧疚感油然而生.虽然计算机已经很快,很多性能问题并不敏感.但是,如果能在底层优化一点,千百万调用的地方累积成起来,也是不小的进步.

react 使用勾子来保持状态,虽然内部的组件函数在每次运行,但结构一样,就会复用旧的状态.这当然利用了代码执行的有序性,安装函数执行中,访问后台的变量.

因为 react 总是在 render,包括 flutter(我视为 react-16),使用者更会在意减少开销.react 使用者总会使用 memo 去包裹组件,以及 useMemo 去减少局部的 render.flutter 里更有 const 修饰,从语言层面,复用不变的结构,不反复去分配与销毁内存——从理论上,这用空间换得了时间.

最近才认识 dart 里的 const,这是我对其它语言一直所期望的.我爱写嵌套的逻辑结构以减少命名,结构中有些部分却不需要每次执行时重新创建与销毁.其实我对 flutter 期待更多,比如一些匿名函数提升到顶层或指定层,可能需要加修饰词.并不需要像 const 一样合并.

函数式编程总让人忽略了内存的分配,只专注于逻辑.似乎有一条路,有唯一方案,通过使用 lambda,获得最简的逻辑结构.比如`Array::forEach((item,index)=>{})`这个回调函数其实只需要 item 与 index 两个参数就可以了,回调函数是调用时立即声明的,Array 本身可以通过闭包传递到里面的.但如果每次声明回调,item 也不必要,因为可以结合 Array 与 index 得到.

```js
array.forEach((index) => {
  const item = array[index];
});
```

而事实上 Array::forEach 的回调函数有 3 个参数,第 3 个参数是 array 本身,其实是尽可能提供了这个方法调用的所有场合,这个 array 是必然已知的,在更多场合下能减少回调函数的临时声明,减少资源消耗.但这个思路下,是否可以将 Array::forEach 的参数,变成 Array::forEach(callback(item,index,array,A,B,C...),A,B,C...)呢?

最近我却在这样写:

```js
function xxx() {
  a = 89;
  b = "dd";
  array.forEach(globalCalback);
}

var a, b;

function globalCalback(item, index) {
  item.call(a, b);
}
```

通过利用 js 的有序单线程,暂存全局,减少回调函数本身的内存分配.这里回调函数当然是每个场合专用的.

更进一步想,函数调用,每次至少创建一个 arguments 的结构,使用完就销毁了.而如果是结合 apply/call,中间可能还要不断截取构造数组,其实开销并不是少的.而且事实上,在 js 世界中,更常用单个 object 来传递多个复合参数,从 jquery 到 react.于是为了参数传递,不仅要制造一个 arguments 结构,还至少会有一个 object.

曾经我偏爱函数调用一气呵成,讨厌面向对象组装参数啰啰嗦嗦(而且深陷对象如何复用的大网).现在看来,面向对象是最好的内存管理方式,即通常一个类型只有一个主调用方法,其余都是组装参数.这样一来用这个类型来充当函数,并不会产生过多内存分配,在单线程中,它的单个实例甚至可以全局复用(有一些可能).

但是面向对象的手动组装仍然是易出错的,其实在新语言中,应该有更多的语法糖,像函数式调用一样,一次性组装好参数,避免意外调用,只要编译后其内部原理仍然是对象组装执行的.
